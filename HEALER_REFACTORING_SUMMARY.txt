================================================================================
HEALER CLASS GAMECONTEXT DEPENDENCY INJECTION REFACTORING
Analysis Report - Agent-Actor-02
================================================================================

PROJECT FILES ANALYZED:
- E:\repo\C++RogueLike\src\ActorTypes\Healer.h (23 lines)
- E:\repo\C++RogueLike\src\ActorTypes\Healer.cpp (49 lines)
- E:\repo\C++RogueLike\src\Core\GameContext.h (66 lines)
- E:\repo\C++RogueLike\src\Game.h (176 lines)
- E:\repo\C++RogueLike\src\Actor\Pickable.h (400+ lines)
- E:\repo\C++RogueLike\src\UI\InventoryUI.cpp (407 lines)

STATUS: Analysis Only - No Code Changes Made
================================================================================

1. GAME REFERENCES FOUND
================================================================================

TOTAL REFERENCES: 4 (All in Healer::use() method, lines 8-26)

Location: src/ActorTypes/Healer.cpp

Line 14: game.message(COLOR_WHITE, "You heal ", false);
Line 15: game.message(COLOR_RED, std::to_string(amountHealed), false);
Line 16: game.message(COLOR_WHITE, " hit points.", true);
Line 22: game.message(COLOR_RED, "Health is already maxed out!", true);

All references are to: game.message()
All in same method: Healer::use(Item& owner, Creature& wearer)

Other methods (load, save, get_type): NO game references

================================================================================

2. UPDATED METHOD SIGNATURES
================================================================================

CURRENT SIGNATURE (Healer.h line 17):
    bool use(Item& owner, Creature& wearer) override;

PROPOSED SIGNATURES:

Header (Healer.h) - ADD:
    struct GameContext;  // Forward declaration
    bool use_with_context(Item& owner, Creature& wearer, GameContext& ctx);

Implementation (Healer.cpp) - ADD:
    bool Healer::use_with_context(Item& owner, Creature& wearer, GameContext& ctx)
    {
        int amountHealed = wearer.destructible->heal(amountToHeal);

        if (amountHealed > 0)
        {
            ctx.message_system->message(COLOR_WHITE, "You heal ", false);
            ctx.message_system->message(COLOR_RED, std::to_string(amountHealed), false);
            ctx.message_system->message(COLOR_WHITE, " hit points.", true);
            return Pickable::use(owner, wearer);
        }
        else
        {
            ctx.message_system->message(COLOR_RED, "Health is already maxed out!", true);
        }
        return false;
    }

NOTE: Keep original use() method for backward compatibility

================================================================================

3. PICKABLE INTERFACE IMPACT
================================================================================

Challenge: Pickable::use() signature defined in base class (Pickable.h:67)
    virtual bool use(Item& owner, Creature& wearer);

Solution: Add new virtual method to Pickable base class

Pickable.h - ADD:
    struct GameContext;  // Forward declaration

    virtual bool use_with_context(Item& owner, Creature& wearer, GameContext& ctx)
    {
        return use(owner, wearer);  // Default: delegate to old method
    }

Benefits:
- Backward compatible
- Allows gradual migration of derived classes
- No breakage of existing code
- Follows Open/Closed Principle

================================================================================

4. CALL SITES REQUIRING UPDATES
================================================================================

PRIMARY CALL SITE:
    File: src/UI/InventoryUI.cpp
    Method: handle_backpack_selection()
    Line: 317

CURRENT CODE:
    bool itemUsed = selectedItem->pickable->use(*selectedItem, player);

UPDATED CODE:
    auto ctx = game.get_context();
    bool itemUsed = selectedItem->pickable->use_with_context(*selectedItem, player, ctx);

SECONDARY LOCATIONS:
    - Test files: src/Items/*.cpp.test.cpp (6 untracked test files)
    - Tests/Combat/: DamageInfoTest.cpp, WeaponDamageRegistryTest.cpp

================================================================================

5. GAMECONTEXT MEMBERS NEEDED
================================================================================

Required by Healer:
    MessageSystem* message_system

Status in GameContext.h (line 38):
    MessageSystem* message_system{ nullptr };  ✓ ALREADY PRESENT

No new GameContext members needed for Healer refactoring!

Full GameContext structure verified to include:
- Map* map
- Gui* gui
- Player* player
- MessageSystem* message_system         ✓ Used by Healer
- RandomDice* dice
- CreatureManager* creature_manager
- LevelManager* level_manager
- RenderingManager* rendering_manager
- InputHandler* input_handler
- GameStateManager* state_manager
- MenuManager* menu_manager
- DisplayManager* display_manager
- GameLoopCoordinator* game_loop_coordinator
- DataManager* data_manager
- TargetingSystem* targeting
- HungerSystem* hunger_system
- Stairs* stairs
- std::vector<std::unique_ptr<Object>>* objects
- InventoryData* inventory_data
- std::vector<std::unique_ptr<Creature>>* creatures
- int* time
- bool* run
- int* game_status

================================================================================

6. IMPLEMENTATION ROADMAP
================================================================================

PHASE 1: Extend Pickable Base Class (SAFE, LOW RISK)
  Files: src/Actor/Pickable.h
  Changes:
    - Add forward declaration: struct GameContext;
    - Add virtual method: use_with_context(Item&, Creature&, GameContext&)
    - Default implementation delegates to use()
  Risk: LOW (additive change, no breaking changes)

PHASE 2: Refactor Healer Class (ISOLATED, LOW RISK)
  Files: src/ActorTypes/Healer.h
          src/ActorTypes/Healer.cpp
  Changes:
    - Add forward declaration: struct GameContext;
    - Add method declaration: use_with_context()
    - Implement new method replacing game.message() with ctx.message_system->message()
    - Keep original use() for compatibility
  Risk: LOW (isolated changes, no dependencies on other changes)

PHASE 3: Update Call Sites (MEDIUM RISK)
  Files: src/UI/InventoryUI.cpp
  Changes:
    - Line 317: Update to call use_with_context() instead of use()
    - Pass GameContext from game.get_context()
  Risk: MEDIUM (requires coordination, affects runtime behavior)

PHASE 4: Test Infrastructure (MEDIUM RISK)
  Files: Test files using Healer
  Changes:
    - Create GameContext test wrapper
    - Mock MessageSystem for tests
    - Update test calls to use use_with_context()
  Risk: MEDIUM (test coverage requirement)

================================================================================

7. REFERENCE PATTERN VALIDATION
================================================================================

Game::get_context() Implementation (Game.h:108):
    GameContext Game::get_context() noexcept;

This method already exists and returns properly initialized GameContext.

Usage Example (in InventoryUI.cpp):
    auto ctx = game.get_context();
    // ctx.message_system points to game.message_system
    // ctx.map points to game.map
    // etc.

This pattern is READY TO USE - no Game class changes needed.

================================================================================

8. COMPLEXITY COMPARISON
================================================================================

Healer vs Other Similar Classes:

HEALER (SIMPLEST - IDEAL CANDIDATE):
  Total game references: 4
  Types: game.message() only
  Method complexity: LOW
  Dependencies: MessageSystem only
  Recommendation: ✓ REFACTOR FIRST

CONFUSER:
  Total game references: 8+
  Types: game.pick_tile(), game.get_actor(), game.message(),
         game.restore_game_display()
  Method complexity: MEDIUM
  Dependencies: TargetingSystem, CreatureManager, RenderingManager, MessageSystem
  Recommendation: REFACTOR SECOND

LIGHTNING_BOLT:
  Total game references: 11+
  Types: game.get_closest_monster(), game.message(), game.render(),
         game.map.get_width(), game.restore_game_display()
  Method complexity: HIGH
  Dependencies: CreatureManager, MessageSystem, RenderingManager, Map
  Recommendation: REFACTOR THIRD

================================================================================

9. DETAILED DEPENDENCIES - HEALER
================================================================================

Direct Dependencies:
  Healer::use() line 10:
    wearer.destructible->heal(amountToHeal)
    └─ Destructible interface method (NOT game dependency)

  Lines 14-16, 22:
    game.message()
    └─ Game class method
       └─ Delegates to game.message_system.message()

Game.h Implementation (lines 145-152):
    void message(int color, std::string_view text, bool isComplete = false)
    { message_system.message(color, text, isComplete); }

Target Pattern (with GameContext):
    ctx.message_system->message(color, text, isComplete)
    └─ Direct access to MessageSystem (already in GameContext)

================================================================================

10. VALIDATION CHECKLIST
================================================================================

Prerequisites (VERIFIED):
  ✓ GameContext.h exists with MessageSystem* member (line 38)
  ✓ Game::get_context() is implemented (Game.h:108)
  ✓ Pickable.h is designed for polymorphism (virtual methods)
  ✓ InventoryUI.cpp includes Game.h (can call get_context())
  ✓ No other Healer code depends on game (only use() method)
  ✓ MessageSystem.h public API includes message() method (line 23)
  ✓ Message colors (COLOR_WHITE, COLOR_RED) defined in Colors.h
  ✓ All required headers available in proposed locations

Success Criteria (TO IMPLEMENT):
  [ ] Healer.h compiles with GameContext forward declaration
  [ ] Healer::use_with_context() compiles and executes correctly
  [ ] All game.message() calls replaced with ctx.message_system->message()
  [ ] Original Healer::use() remains for backward compatibility
  [ ] InventoryUI.cpp updated to call use_with_context()
  [ ] No compiler errors or warnings
  [ ] Existing tests continue to pass
  [ ] New behavior produces identical game messages

================================================================================

11. RISK ASSESSMENT
================================================================================

TECHNICAL RISKS (LOW):
  - Adding new virtual method: LOW RISK (non-breaking)
  - Pickable base class changes: LOW RISK (additive only)
  - Healer implementation: LOW RISK (isolated changes)
  - Message system access: LOW RISK (already in GameContext)

INTEGRATION RISKS (MEDIUM):
  - InventoryUI call site updates: MEDIUM RISK (behavior change)
  - Test updates: MEDIUM RISK (test coverage)
  - GameContext initialization: LOW RISK (already working)

COMPATIBILITY RISKS (LOW):
  - Backward compatibility: LOW RISK (old method remains)
  - Other derived classes: LOW RISK (new method is optional)
  - API stability: LOW RISK (extending, not breaking)

MITIGATION STRATEGIES:
  1. Keep original use() method as fallback
  2. Implement new method as override in Pickable
  3. Update tests before production changes
  4. Validate GameContext initialization in all contexts
  5. Maintain git history for rollback if needed

================================================================================

12. FILES REQUIRING CHANGES
================================================================================

Modified Files:
  1. src/Actor/Pickable.h (ADD)
     - struct GameContext forward declaration
     - virtual bool use_with_context() method

  2. src/ActorTypes/Healer.h (ADD)
     - struct GameContext forward declaration
     - bool use_with_context() declaration

  3. src/ActorTypes/Healer.cpp (ADD)
     - bool Healer::use_with_context() implementation
     - Replace game.message() with ctx.message_system->message()

  4. src/UI/InventoryUI.cpp (UPDATE)
     - Line 317: Replace use() call with use_with_context()
     - Pass GameContext parameter

Unchanged Files:
  - src/Core/GameContext.h (MessageSystem already present)
  - src/Game.h (get_context() already implemented)
  - src/Colors/Colors.h (color constants still used)
  - Other Healer-independent code

Test Files:
  - Tests using Healer::use() (TBD - specific test file locations)
  - May need GameContext mock wrapper

================================================================================

13. CODE SNIPPETS - BEFORE AND AFTER
================================================================================

BEFORE: Healer.cpp (Current - Lines 8-26)
-----
bool Healer::use(Item& owner, Creature& wearer)
{
    int amountHealed = wearer.destructible->heal(amountToHeal);

    if (amountHealed > 0)
    {
        game.message(COLOR_WHITE, "You heal ", false);
        game.message(COLOR_RED, std::to_string(amountHealed), false);
        game.message(COLOR_WHITE, " hit points.", true);

        return Pickable::use(owner, wearer);
    }
    else
    {
        game.message(COLOR_RED, "Health is already maxed out!", true);
    }

    return false;
}

AFTER: Healer.cpp (Proposed - New Method)
-----
bool Healer::use_with_context(Item& owner, Creature& wearer, GameContext& ctx)
{
    int amountHealed = wearer.destructible->heal(amountToHeal);

    if (amountHealed > 0)
    {
        ctx.message_system->message(COLOR_WHITE, "You heal ", false);
        ctx.message_system->message(COLOR_RED, std::to_string(amountHealed), false);
        ctx.message_system->message(COLOR_WHITE, " hit points.", true);

        return Pickable::use(owner, wearer);
    }
    else
    {
        ctx.message_system->message(COLOR_RED, "Health is already maxed out!", true);
    }

    return false;
}

BEFORE: InventoryUI.cpp (Line 317)
-----
bool itemUsed = selectedItem->pickable->use(*selectedItem, player);

AFTER: InventoryUI.cpp (Line 317)
-----
auto ctx = game.get_context();
bool itemUsed = selectedItem->pickable->use_with_context(*selectedItem, player, ctx);

================================================================================

14. FINAL RECOMMENDATIONS
================================================================================

RECOMMENDATION: Proceed with Healer refactoring using Phase 1-4 approach

RATIONALE:
  1. Healer is the simplest case with minimal game dependencies (4 refs)
  2. All required GameContext members already exist
  3. Refactoring is low-risk and isolated
  4. Serves as template for similar classes (Confuser, LightningBolt)
  5. Demonstrates GameContext dependency injection pattern effectively
  6. Backward compatibility maintained through base class default

NEXT STEPS:
  1. Review this analysis document for accuracy
  2. Implement Phase 1: Extend Pickable.h with GameContext support
  3. Implement Phase 2: Refactor Healer.h and Healer.cpp
  4. Implement Phase 3: Update InventoryUI.cpp call site
  5. Implement Phase 4: Update and validate tests
  6. Create pull request with all changes
  7. Run test suite to validate behavior
  8. Document pattern in project wiki for other classes

ESTIMATED EFFORT:
  - Phase 1: 15 minutes
  - Phase 2: 15 minutes
  - Phase 3: 10 minutes
  - Phase 4: 20 minutes
  - Testing & validation: 15 minutes
  - Total: ~75 minutes

================================================================================

Report Generated: 2026-01-08
Analysis Status: COMPLETE - NO CODE CHANGES MADE
Ready for Implementation Review
================================================================================
